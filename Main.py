"""
This application is built using the cmd2 module primarily and it is a command line BASH like interpreter.

Welcome to Qt Tool.
This command line interface program was designed for programmers who rely heavily on using
PyQt5 and generated python code from the PyQt designer.

This application is geared towards simplicity trying to make generating such applications
as swift and easy as possible.

In this app, you specify an input file (a .py file generated by PyQt) and an output file of your
choosing. You have the option to generate actions, buttons, imports or all. What that means specifically
for buttons or actions is that the app will scan the input folder to find all variables of type QPushButton
or QAction and will generate a .triggered/.clicked statement and then at the end of the file will generate
functions for the respective buttons/actions. It is very bare-bones but quite useful as it is more or less
creating a layout that you will use.

You do not have to worry about useless generated code because 1. the code is generated with comments
and 2. the code is minimal

You will be able to generate the basic structure of the application but as for the algorithms
of your commands, you must do the coding yourself in the Python file that will be generated with
code by this application.

You also have the ability to save your information in a JSON file and load information from that
file later on if you need it.

You are able to use ? symbol before any command to learn more about that command, its arguments,
and what it does. You may also use that symbol in the beginning to see the list of commands
available to you inside this application.

Command completion is also a feature made possible by the cmd2 module along with many other features
such as use of aliases and abilities to run scripts with the commands of this CLI. It is worth noting
that using cmd2 also makes the application stable for any explicitly uncaught errors are caught by the
module itself.
"""
import argparse
import json
import os
import pprint

from cmd2 import Cmd, with_argparser_and_unknown_args, with_category
from colorama import init, Fore

import methods as meth

init(autoreset=True)

open_argparser = argparse.ArgumentParser()
open_argparser.add_argument('-of', '--outfile', action='store_true',
                            help='Open the output file where your code is.')
open_argparser.add_argument('-if', '--infile', action='store_true',
                            help='Open original input file.')
open_argparser.add_argument('-j', '--json', action='store_true',
                            help='Open the .json file where your config is.')

import_argparser = argparse.ArgumentParser()
import_argparser.add_argument('-ap', '--addpackage', action='store_true',
                              help='Add import statement with certain package.')
import_argparser.add_argument('-am', '--addmodule', action='store_true',
                              help='Add import statement with entire module.')

search_argparser = argparse.ArgumentParser()
search_argparser.add_argument('-w', '--widget', action='store_true',
                              help='Search for all variables that contain specified widget.')
search_argparser.add_argument('-l', '--line', action='store_true',
                              help='Search for all lines that contain your input.')
search_argparser.add_argument('-ln', '--linenumber', action='store_true',
                              help='Search for all lines that contain your input.')

gen_argparser = argparse.ArgumentParser()
gen_argparser.add_argument('-b', '--buttons', action='store_true',
                           help='Generate functions for all buttons.')
gen_argparser.add_argument('-a', '--actions', action='store_true',
                           help='Generate functions for all buttons.')
gen_argparser.add_argument('-i', '--imports', action='store_true',
                           help='Generate import statements at file start.')
gen_argparser.add_argument('-c', '--copy', action='store_true',
                           help='Generate ia copy of input file.')
gen_argparser.add_argument('-A', '--All', action='store_true',
                           help='Generate imports, actions, and buttons.')

view_argparser = argparse.ArgumentParser()
view_argparser.add_argument('-of', '--outfile', action='store_true',
                            help='View output file.')
view_argparser.add_argument('-if', '--infile', action='store_true',
                            help='View original input file.')
view_argparser.add_argument('-j', '--json', action='store_true',
                            help='View json file.')
view_argparser.add_argument('-f', '--file', action='store_true',
                            help='View file of specified path.')


# noinspection PyUnusedLocal
class App(Cmd):
    intro = "Welcome to Qt Tool"
    prompt = ">>>"
    file = None
    info = {
        "save_path": "",
        "input_file_path": "",
        "output_file_path": "",
        "imports": [],
    }

    @with_argparser_and_unknown_args(open_argparser)
    def do_open(self, opts, arg):
        """Open specified file/folder"""
        try:
            if opts.outfile:
                meth.open_file(self.info['output_file_path'])
            elif opts.infile:
                meth.open_file(self.info["input_file_path"])
            elif opts.json:
                meth.open_file(self.info['save_path'])
            else:
                meth.open_file(arg[0])
        except WindowsError:
            print(f"{Fore.RED}The file does not exist. Check path to file or create the file.")
        except IndexError:
            print(f"{Fore.RED}Command may be incomplete.")

    @with_argparser_and_unknown_args(import_argparser)
    def do_import(self, opts, arg):
        """Add imports to your file"""
        if opts.addmodule:
            namespace = input(f"{Fore.BLUE}Would you like to add a namespace?(y/n)")
            if namespace == "y":
                name = input(f"{Fore.BLUE}Namespace: ")
                self.info["imports"].append(["namespace", arg[0], name])
            else:
                self.info["imports"].append(arg)
        elif opts.addpackage:
            module = input(f"{Fore.BLUE}What module is this package located in? ")
            self.info["imports"].append(["package", module, arg[0]])
        else:
            print(f"{Fore.RED}You must add a valid argument for the command.")

    @with_category("Files")
    def do_outfile(self, arg):
        """Specify the output file"""
        self.info["output_file_path"] = arg.args

    @with_category("Files")
    def do_infile(self, arg):
        """Specify the input file that will be analyzed"""
        self.info["input_file_path"] = arg.args

    @with_argparser_and_unknown_args(search_argparser)
    def do_search(self, opts, arg):
        """Returns list of variables of the type of the specified widget"""
        try:
            if opts.widget:
                meth.search_widget(self.info["input_file_path"], arg[0])
            elif opts.line:
                meth.search_line(self.info["input_file_path"], arg[0])
            elif opts.linenumber:
                meth.search_line_nums(self.info["input_file_path"], arg[0])
            else:
                print(f"{Fore.RED}Input Proper Argument.")
        except IndexError as e:
            print(f"{Fore.RED}Incomplete command.")

    # def do_organize(self, arg):
    #     """Organize your PyQt file code based on the criteria you specify"""
    #     try:
    #         pass
    #     except Exception as e:
    #         print(f"{Fore.RED}{e}")

    @with_argparser_and_unknown_args(view_argparser)
    def do_view(self, opts, arg):
        """"""
        try:
            if opts.infile:
                meth.view(self.info["input_file_path"])
            elif opts.outfile:
                meth.view(self.info["output_file_path"])
            elif opts.json:
                meth.view(self.info["save_path"])
            elif opts.file:
                meth.view(arg[0])
            else:
                print(f"{Fore.RED}You must specify a proper argument.")
        except (FileNotFoundError, FileExistsError):
            print(f"{Fore.RED}No such file or directory. Check path.")
        except PermissionError:
            print(f"{Fore.RED}You do not have permission to access specified file/directory.")
        except IndexError:
            print(f"{Fore.RED}Command incorrect.\nReview.")

    @with_category("JSON")
    def do_save(self, arg):
        """Save the settings you have specified so far in a JSON file."""
        try:
            with open(os.path.abspath(self.info['save_path']), 'w+') as file:
                json.dump(self.info, file, sort_keys=True, indent=4)
            print(f"{Fore.GREEN}Saved Successfully.")
        except (FileNotFoundError, FileExistsError):
            print(f"{Fore.RED}You must specify a save path.")

    @with_category("JSON")
    def do_load(self, ):
        """Load settings from a JSON file."""
        try:
            file = input("Path: ")
            with open(os.path.abspath(file), 'r+') as json_file:
                self.info = json.load(json_file)
            print(f"{Fore.GREEN}Loaded Successfully.")
        except Exception as e:
            print(f"{Fore.RED}{e}")

    @with_argparser_and_unknown_args(gen_argparser)
    def do_gen(self, opts, arg):
        """Generate functions for actions and buttons"""
        try:
            if opts.buttons:
                meth.gen_copy(self.info["input_file_path"], self.info["output_file_path"])
                meth.gen(self.info["output_file_path"], "QPushButton", "clicked")
            elif opts.actions:
                meth.gen_copy(self.info["input_file_path"], self.info["output_file_path"])
                meth.gen(self.info["output_file_path"], "QAction", "triggered")
            elif opts.imports:
                meth.gen_copy(self.info["input_file_path"], self.info["output_file_path"])
                meth.gen_imports(self.info["output_file_path"], self.info["imports"])
            elif opts.copy:
                meth.gen_copy(self.info["input_file_path"], self.info["output_file_path"])
            elif opts.All:
                meth.gen_copy(self.info["input_file_path"], self.info["output_file_path"])
                meth.gen(self.info["output_file_path"], "QPushButton", "clicked")
                meth.gen(self.info["output_file_path"], "QAction", "triggered")
                meth.gen_imports(self.info["output_file_path"], self.info["imports"])
            else:
                print(f"{Fore.RED}Specify proper argument.\nYour command seems to be incorrect.")
        except Exception as e:
            print(f"{Fore.RED}{e}")

    @with_category("JSON")
    def do_json(self, arg):
        """Specify complete path to JSON file. Path can be relative or absolute."""
        self.info["save_path"] = arg.args

    @with_category("Console")
    def do_prompt(self, arg):
        """Change prompt of the console"""
        self.prompt = arg

    @with_category("Console")
    def do_about(self, arg):
        """Learn about this CLI"""
        print("""
            This application is built using the cmd2 module primarily and it is a command line BASH like interpreter.
            
            Welcome to Qt Tool.
            This command line interface program was designed for programmers who rely heavily on using
            PyQt5 and generated python code from the PyQt designer.
            
            This application is geared towards simplicity trying to make generating such applications
            as swift and easy as possible.
            
            In this app, you specify an input file (a .py file generated by PyQt) and an output file of your 
            choosing. You have the option to generate actions, buttons, imports or all. What that means specifically
            for buttons or actions is that the app will scan the input folder to find all variables of type QPushButton
            or QAction and will generate a .triggered/.clicked statement and then at the end of the file will generate 
            functions for the respective buttons/actions. It is very bare-bones but quite useful as it is more or less
            creating a layout that you will use.
            
            You do not have to worry about useless generated code because 1. the code is generated with comments
            and 2. the code is minimal
            
            You will be able to generate the basic structure of the application but as for the algorithms
            of your commands, you must do the coding yourself in the Python file that will be generated with
            code by this application.
            
            You also have the ability to save your information in a JSON file and load information from that
            file later on if you need it.
            
            You are able to use ? symbol before any command to learn more about that command, its arguments,
            and what it does. You may also use that symbol in the beginning to see the list of commands
            available to you inside this application.
            
            Command completion is also a feature made possible by the cmd2 module along with many other features
            such as use of aliases and abilities to run scripts with the commands of this CLI. It is worth noting
            that using cmd2 also makes the application stable for any explicitly uncaught errors are caught by the
            module itself.
            """)

    @with_category("Settings")
    def do_info(self, arg):
        """Show the information that has been inputted for this app"""
        pprint.pprint(self.info)

    @with_category("Settings")
    def do_reset(self, arg):
        """Reset all the values that you have inputted and clear the console"""
        self.info["save_path"] = ""
        self.info["input_file_path"] = ""
        self.info["output_file_path"] = ""
        self.do_clear()

    @staticmethod
    @with_category("Console")
    def do_clear(arg):
        """Clear the console."""
        try:
            os.system('cls')
        except OSError:
            os.system('clear')

    @staticmethod
    @with_category("Console")
    def do_quit(arg):
        """Quit the console."""
        quit()


if __name__ == "__main__":
    app = App()
    app.cmdloop()
